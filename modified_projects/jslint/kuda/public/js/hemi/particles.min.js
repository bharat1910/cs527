/*
 * Port of O3D's gpu-enabled particle system to Three.js with minor modifications.
 * @author Erik Kitson
 */

/*
 * Copyright 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var hemi=hemi||{};(function(){function g(a){var b=new Uint8Array(a.length),c;for(var d=0;d<a.length;++d)c=a[d]*256,b[d]=c>255?255:c<0?0:c;return b}function f(a,b,c,d,e){var f=this.material.attributes.positionStartTime,g=this._particleSystem._randomFunction,h=function(a){return(g()-.5)*a*2},i=function(a,b){var c=[];for(var d=0,e=a.length;d<e;++d)c[d]=a[d]+h(b[d]);return c};for(var j=a,k=a+b;j<k;++j){var l=i(d,e);for(var m=0;m<4;++m){var n=j*4+m;f.value[n].x=l[0],f.value[n].y=l[1],f.value[n].z=l[2],f.value[n].w=c}}f.needsUpdate=!0}function e(b){this.validateParameters(b);var c=a[b.billboard?"particle2d":"particle3d"];this.material.attributes=THREE.UniformsUtils.clone(c.attributes),this.material.uniforms=THREE.UniformsUtils.clone(c.uniforms),this.material.vertexShader=c.vertexShader,this.material.fragmentShader=c.fragmentShader,this._timeParam=this.material.uniforms.time}function d(a,c,d){var e=this.material.attributes,f=this.material.uniforms,g=e.uvLifeTimeFrameStart,h=e.positionStartTime,i=e.velocityStartSize,j=e.accelerationEndSize,k=e.spinStartSpinSpeed,l=e.orientation,m=e.colorMult,n=c.worldVelocity,o=c.worldAcceleration,p=this._particleSystem._randomFunction,q=function(a){return(p()-.5)*a*2},r=function(a,b){var c=[];for(var d=0,e=a.length;d<e;++d)c[d]=a[d]+q(b[d]);return c};f.colorSampler.texture=this._colorTexture,f.rampSampler.texture=this._rampTexture,f.timeRange.value=c.timeRange,f.numFrames.value=c.numFrames,f.frameDuration.value=c.frameDuration,f.worldVelocity.value.set(n[0],n[1],n[2]),f.worldAcceleration.value.set(o[0],o[1],o[2]),c.billboard&&(f.viewInverse.value=this._camera.matrixWorld);for(var s=0;s<a;++s){d&&d(s,c);var t=c.lifeTime,u=c.startTime===null?s*t/a:c.startTime,v=c.frameStart+q(c.frameStartRange),w=r(c.position,c.positionRange),x=r(c.velocity,c.velocityRange),y=r(c.acceleration,c.accelerationRange),z=r(c.colorMult,c.colorMultRange),A=c.spinStart+q(c.spinStartRange),B=c.spinSpeed+q(c.spinSpeedRange),C=c.startSize+q(c.startSizeRange),D=c.endSize+q(c.endSizeRange),E=c.orientation;for(var F=0;F<4;++F){var G=s*4+F;g.value[G]=new THREE.Vector4(b[F][0],b[F][1],t,v),h.value[G]=new THREE.Vector4(w[0],w[1],w[2],u),i.value[G]=new THREE.Vector4(x[0],x[1],x[2],C),j.value[G]=new THREE.Vector4(y[0],y[1],y[2],D),k.value[G]=new THREE.Vector4(A,B,0,0),m.value[G]=new THREE.Vector4(z[0],z[1],z[2],z[3]),l&&(l.value[G]=new THREE.Vector4(E[0],E[1],E[2],E[3]))}}g.needsUpdate=!0,h.needsUpdate=!0,i.needsUpdate=!0,j.needsUpdate=!0,k.needsUpdate=!0,m.needsUpdate=!0,l&&(l.needsUpdate=!0)}function c(a){for(var b=0;b<a;++b){for(var c=0;c<4;++c)this.shape.vertices.push(new THREE.Vertex);var d=b*4;this.shape.faces.push(new THREE.Face3(d,d+1,d+3)),this.shape.faces.push(new THREE.Face3(d+1,d+2,d+3))}}hemi.particles=hemi.particles||{};var a={particle3d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},orientation:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 orientation; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\nvarying float v_discard;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = positionStartTime.xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz\n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  if (startTime < 0.0) {\n    v_discard = 1.0;\n    gl_Position = vec4(0);\n    return;\n  } else {\n    v_discard = -1.0;\n  }\n\n  float localTime = mod((time - timeOffset - startTime), timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0.0,\n                               (uv.x * s - uv.y * c) * size, 1.0);\n  vec3 center = velocity * localTime +\n                  acceleration * localTime * localTime + \n                  position;\n  \n      vec4 q2 = orientation + orientation;\n      vec4 qx = orientation.xxxw * q2.xyzx;\n      vec4 qy = orientation.xyyw * q2.xyzy;\n      vec4 qz = orientation.xxzw * q2.xxzz;\n  \n      mat4 localMatrix = mat4(\n        (1.0 - qy.y) - qz.z, \n        qx.y + qz.w, \n        qx.z - qy.w,\n        0,\n  \n        qx.y - qz.w, \n        (1.0 - qx.x) - qz.z, \n        qy.z + qx.w,\n        0,\n  \n        qx.z + qy.w, \n        qy.z - qx.w, \n        (1.0 - qx.x) - qy.y,\n        0,\n  \n        center.x, center.y, center.z, 1.0);\n  rotatedPoint = localMatrix * rotatedPoint;\n  gl_Position = projectionMatrix * modelViewMatrix * rotatedPoint;\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\nvarying float v_discard;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  if (v_discard > 0.0) {\n    discard;\n  }\n\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"},particle2d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{viewInverse:{type:"m4",value:null},worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform mat4 viewInverse;\nuniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\nvarying float v_discard;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = (objectMatrix * vec4(positionStartTime.xyz, 1.0)).xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz \n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  if (startTime < 0.0) {\n    v_discard = 1.0;\n    gl_Position = vec4(0);\n    return;\n  } else {\n    v_discard = -1.0;\n  }\n\n  float localTime = mod((time - timeOffset - startTime), timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  vec3 basisX = viewInverse[0].xyz;\n  vec3 basisZ = viewInverse[1].xyz;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec2 rotatedPoint = vec2(uv.x * c + uv.y * s, \n                               -uv.x * s + uv.y * c);\n  vec3 localPosition = vec3(basisX * rotatedPoint.x +\n                                basisZ * rotatedPoint.y) * size +\n                         velocity * localTime +\n                         acceleration * localTime * localTime + \n                         position;\n\n  gl_Position = (projectionMatrix * viewMatrix * vec4(localPosition, 1.0));\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\nvarying float v_discard;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  if (v_discard > 0.0) {\n    discard;\n  }\n\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"}},b=[[-0.5,-0.5],[.5,-0.5],[.5,.5],[-0.5,.5]];hemi.particles.System=function(a){var b=[0,.2,.7,1,.7,.2,0,0],c=[];for(var d=0;d<8;++d)for(var e=0;e<8;++e){var f=b[e]*b[d];c.push(f,f,f,f)}var h=g(c),i=new THREE.DataTexture(h,8,8,THREE.RGBAFormat),j=g([1,1,1,1,1,1,1,.5,1,1,1,0]),k=new THREE.DataTexture(j,3,1,THREE.RGBAFormat);k.wrapT=THREE.RepeatWrapping,i.needsUpdate=k.needsUpdate=!0,this._randomFunction=a||function(){return Math.random()},this.defaultColorTexture=i,this.defaultRampTexture=k,this.emitters=[]},hemi.particles.System.prototype.createEmitter=function(a,b){return new hemi.particles.Emitter(this,a,b)},hemi.particles.System.prototype.createTrail=function(a,b,c,d,e){return new hemi.particles.Trail(this,a,b,c,d,e)},hemi.particles.System.prototype.update=function(a){for(var b=0,c=this.emitters.length;b<c;++b)this.emitters[b]._timeParam.value+=a},hemi.particles.Spec=function(){this.numParticles=1,this.numFrames=1,this.frameDuration=1,this.frameStart=0,this.frameStartRange=0,this.timeRange=99999999,this.startTime=null,this.lifeTime=1,this.lifeTimeRange=0,this.startSize=1,this.startSizeRange=0,this.endSize=1,this.endSizeRange=0,this.position=[0,0,0],this.positionRange=[0,0,0],this.velocity=[0,0,0],this.velocityRange=[0,0,0],this.acceleration=[0,0,0],this.accelerationRange=[0,0,0],this.spinStart=0,this.spinStartRange=0,this.spinSpeed=0,this.spinSpeedRange=0,this.colorMult=[1,1,1,1],this.colorMultRange=[0,0,0,0],this.worldVelocity=[0,0,0],this.worldAcceleration=[0,0,0],this.billboard=!0,this.orientation=[0,0,0,1]},hemi.particles.Emitter=function(a,b,c){this._camera=b,this._colorTexture=c||null,this._particleSystem=null,this._rampTexture=null,this._timeParam=null,this.material=new THREE.ShaderMaterial({blending:THREE.AdditiveBlending,depthWrite:!1,transparent:!0}),this.material.name="particles",this.shape=new THREE.Geometry,a&&(this._colorTexture=c||a.defaultColorTexture,this._rampTexture=a.defaultRampTexture,this._particleSystem=a,a.emitters.push(this))},hemi.particles.Emitter.prototype.setBlending=function(a){this.material.blending=a},hemi.particles.Emitter.prototype.setColorRamp=function(a){var b=a.length/4;b%1!==0&&hemi.error("colorRamp must have multiple of 4 entries");var c=g(a);this._rampTexture===this._particleSystem.defaultRampTexture||this._rampTexture.image.width!==b?(this._rampTexture=new THREE.DataTexture(c,b,1,THREE.RGBAFormat),this._rampTexture.wrapT=THREE.RepeatWrapping,this._rampTexture.needsUpdate=!0,this.material.uniforms.rampSampler&&(this.material.uniforms.rampSampler.texture=this._rampTexture)):this._rampTexture.image.data=c},hemi.particles.Emitter.prototype.validateParameters=function(a){var b=new hemi.particles.Spec;for(var c in a)typeof b[c]=="undefined"&&hemi.error('unknown particle parameter "'+c+'"');for(c in b)typeof a[c]=="undefined"&&(a[c]=b[c])},hemi.particles.Emitter.prototype.setParameters=function(a,b){e.call(this,a);var f=a.numParticles;c.call(this,f),d.call(this,f,a,b)},hemi.particles.Emitter.prototype.createOneShot=function(a){return new hemi.particles.OneShot(this,a)},hemi.particles.OneShot=function(a,b){this._emitter=a,this._timeOffsetParam=a.material.uniforms.timeOffset,this._transform=new THREE.Mesh(a.shape,a.material),this._transform.doubleSided=!0,this._transform.visible=!1,this._transform.matrixAutoUpdate=!1,b&&b.add(this._transform)},hemi.particles.OneShot.prototype.trigger=function(a,b){b&&b.add(this._transform),a&&(this._transform.position.copy(a),this._transform.updateMatrix()),this._transform.visible=!0,this._timeOffsetParam.value=this._emitter._timeParam.value},hemi.particles.Trail=function(a,b,f,g,h,i){hemi.particles.Emitter.call(this,a,b,h),this._birthIndex=0,this._maxParticles=f,this._parameters=g,this._paramSetter=i,g.startTime=-1,this.shape.dynamic=!0,c.call(this,f),e.call(this,g),d.call(this,f,g,i)},hemi.particles.Trail.prototype=new hemi.particles.Emitter,hemi.particles.Trail.constructor=hemi.particles.Trail,hemi.particles.Trail.prototype.birthParticles=function(a){var b=this._parameters.numParticles,c=this._parameters.positionRange,d=this._timeParam.value;while(this._birthIndex+b>=this._maxParticles){var e=this._maxParticles-this._birthIndex;f.call(this,this._birthIndex,e,d,a,c),b-=e,this._birthIndex=0}f.call(this,this._birthIndex,b,d,a,c),this._birthIndex+=b}})()
